Report Author: John Rost

   For our third and final project of the semester, I was tasked with implementing an access control mechanism which would allow for the hardware to handle finding
pages which are already in memory, alongside the implementation of two separate replacement algorithms for new pages of memory: FIFO and TC. The most difficult task initially was getting used to the new symantics and function calls I would be using throughout the project, such as mprotect, sigaction, etc. I communicated with each other frequently while coming up with ideas for how to tackle the problems that I was facing, and each of us had a hand in designing our code. The biggest problem I had was correctly implementing the fault_types for our mm_logger calls; I had a great deal of difficulty in properly getting each fault type to correctly display all of the time, and because of the inconsistency with our original implementation of typing, I decided to cut most of it out. More often than not, I opted to just leave the types at 0. Our code's structure follows a fairly logical path. I have a fifo and tc struct, which allow us to store page information and create circularly linked lists. Our mm_innit function makes a choice between using our fifo algorithm or our tc one, depending on what policy is passed as input. In both our fifo and tc algorithms, I first check if the page is already within physical memory. After that, I simply need to handle the corresponding faults and procedures for when the pages are not already contained within the physical memory. This project took a great deal of time spent on research and troubleshooting various kinds of errors, and I am very proud of the work I accomplished.
